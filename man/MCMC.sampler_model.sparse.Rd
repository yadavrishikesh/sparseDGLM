% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler_model-sparse.R
\name{MCMC.sampler_model.sparse}
\alias{MCMC.sampler_model.sparse}
\title{MCMC Sampler for Sparse Spatio-Temporal Dynamic Generalized Linear Model}
\usage{
MCMC.sampler_model.sparse(
  model,
  data_lik,
  nt,
  ns,
  p,
  q,
  Y.o,
  data.log.mean,
  data.mean,
  Y.intpl,
  Y.frcast,
  Y.st,
  ind_NA_Y,
  X.o,
  quad.X.o,
  X.intpl,
  X.frcast,
  X.st,
  X.p,
  Ft.o,
  F.mat.o,
  Ft.frcast,
  m0.R,
  C0.R,
  m0.theta,
  C0.theta,
  G,
  delta,
  A.proj.o,
  A.proj.p,
  c.mat.o,
  g1.mat.o,
  g2.mat.o,
  spatInt.ind,
  forcast.ind,
  samples.store,
  N.MCMC,
  burn_in1,
  burn_in2,
  adapt_seq,
  thin,
  adapt,
  tun_r,
  tun_kappa,
  tun_lambda,
  print.result,
  traceplot,
  true.values,
  init_beta,
  init_lambda,
  simulation,
  init.seed,
  ...
)
}
\arguments{
\item{data_lik}{Character, specifying the data likelihood (e.g., `"Poisson"`, `"NegB"`, `"lNormal"`, etc.).}

\item{nt}{Integer, the number of time points in the dataset.}

\item{ns}{Integer, the number of spatial locations.}

\item{p}{Integer, the number of dynamic temporal covariates.}

\item{q}{Integer, the number of fixed covariates.}

\item{Y.o}{Matrix of observed data (excluding spatial interpolation indices).}

\item{data.log.mean}{Numeric, the mean of the log-transformed observed data.}

\item{data.mean}{Numeric, the mean of the observed data.}

\item{Y.intpl}{Matrix of data for spatial interpolation.}

\item{Y.frcast}{Matrix of forecasted data for future time points.}

\item{Y.st}{Matrix of spatio-temporal data.}

\item{ind_NA_Y}{Logical matrix indicating missing values in `Y.o`.}

\item{X.o}{Matrix of fixed covariates for observed data.}

\item{quad.X.o}{Quadratic form of the design matrix `X.o`.}

\item{X.intpl}{Matrix of fixed covariates for spatial interpolation.}

\item{X.frcast}{Matrix of fixed covariates for forecasting.}

\item{X.st}{Matrix of fixed covariates for spatio-temporal data.}

\item{X.p}{Matrix of fixed covariates for prediction.}

\item{Ft.o}{Matrix of dynamic temporal covariates for observed data.}

\item{F.mat.o}{3D array of dynamic temporal covariates for observed data.}

\item{Ft.frcast}{Matrix of dynamic temporal covariates for forecasting.}

\item{m0.R}{Numeric, initial value for the SPDE spatial random effect.}

\item{C0.R}{Numeric, prior variance for the SPDE spatial random effect.}

\item{m0.theta}{Vector, initial value for dynamic temporal covariates.}

\item{C0.theta}{Matrix, prior covariance matrix for dynamic temporal covariates.}

\item{G}{Transition matrix for the state-space model.}

\item{delta}{Numeric, the maximum distance between the observed locations.}

\item{A.proj.o}{Projection matrix for the observed spatial locations.}

\item{A.proj.p}{Projection matrix for the predicted spatial locations.}

\item{c.mat.o}{Matrix representing the 0th-order basis functions for SPDE.}

\item{g1.mat.o}{Matrix representing the 1st-order basis functions for SPDE.}

\item{g2.mat.o}{Matrix representing the 2nd-order basis functions for SPDE.}

\item{spatInt.ind}{Vector of spatial interpolation indices.}

\item{forcast.ind}{Vector of forecast indices.}

\item{samples.store}{Integer, the number of MCMC samples to store.}

\item{N.MCMC}{Integer, the total number of MCMC iterations.}

\item{burn_in1}{Integer, the number of iterations for the first burn-in period.}

\item{burn_in2}{Integer, the number of iterations for the second burn-in period.}

\item{adapt_seq}{Vector, indicating the sequence of iterations for adaptation.}

\item{thin}{Integer, the thinning interval for MCMC samples.}

\item{adapt}{Integer, the adaptation interval.}

\item{tun_r}{Numeric, tuning parameter for `r` in the negative binomial likelihood.}

\item{tun_kappa}{Numeric, tuning parameter for `kappa` (spatial range parameter).}

\item{tun_lambda}{Numeric, tuning parameter for `lambda`.}

\item{print.result}{Logical, if `TRUE`, prints the MCMC results.}

\item{traceplot}{Logical, if `TRUE`, generates trace plots of MCMC samples.}

\item{true.values}{List of true parameter values (optional).}

\item{init_beta}{initial values for beta set by pre-run GLM counterpart}

\item{init_lambda}{initial values for linear predictors set by pre-run GLM counterpart}

\item{simulation}{Logical, if `TRUE`, the function runs in simulation mode.}

\item{init.seed}{Integer, seed for random number generation to ensure reproducibility.}

\item{...}{Additional arguments passed to other methods.}
}
\value{
A list containing MCMC samples, trace plots, convergence diagnostics, and predictions.
}
\description{
This function performs MCMC sampling for a sparse spatio-temporal dynamic generalized linear model (DGLM) using a Gaussian random field approximation through SPDE. It handles spatial interpolation and forecasting and allows for various data likelihoods.
}
\examples{
data_lik <- "Poisson"
nt <- 10
ns <- 5
p <- 3
q <- 2
Y.o <- matrix(rpois(50, lambda = 3), nrow = 10)
data.log.mean <- log(mean(Y.o))
data.mean <- mean(Y.o)
Y.intpl <- matrix(rpois(20, lambda = 3), nrow = 4)
Y.frcast <- matrix(rpois(10, lambda = 3), nrow = 2)
Y.st <- matrix(rpois(20, lambda = 3), nrow = 4)
X.o <- matrix(rnorm(100), nrow = 10)
quad.X.o <- t(X.o) \%*\% X.o
X.intpl <- matrix(rnorm(40), nrow = 4)
X.frcast <- matrix(rnorm(20), nrow = 2)
X.st <- matrix(rnorm(40), nrow = 4)
Ft.o <- matrix(rnorm(30), nrow = 10)
F.mat.o <- array(rnorm(150), dim = c(10, 5, 3))
Ft.frcast <- matrix(rnorm(6), nrow = 2)
m0.R <- 0
C0.R <- 1
m0.theta <- rep(0, 3)
C0.theta <- diag(5, 3)
G <- diag(1, 3)
delta <- 0.1
A.proj.o <- matrix(rnorm(30), nrow = 10)
A.proj.p <- matrix(rnorm(20), nrow = 5)
c.mat.o <- matrix(rnorm(25), nrow = 5)
g1.mat.o <- matrix(rnorm(25), nrow = 5)
g2.mat.o <- matrix(rnorm(25), nrow = 5)
spatInt.ind <- 1:2
forcast.ind <- 1:2
samples.store <- 100
N.MCMC <- 1000
burn_in1 <- 200
burn_in2 <- 500
adapt_seq <- seq(100, 1000, by = 100)
thin <- 10
adapt <- 100
tun_r <- 0.1
tun_kappa <- 0.1
tun_lambda <- 0.1
print.result <- TRUE
traceplot <- TRUE
true.values <- NULL
simulation <- FALSE
init.seed <- 123
result <- MCMC.sampler_model.sparse(data_lik, nt, ns, p, q, Y.o, data.log.mean, data.mean,
                                    Y.intpl, Y.frcast, Y.st, NULL, X.o, quad.X.o, X.intpl,
                                    X.frcast, X.st, X.o, Ft.o, F.mat.o, Ft.frcast, m0.R, C0.R,
                                    m0.theta, C0.theta, G, delta, A.proj.o, A.proj.p,
                                    c.mat.o, g1.mat.o, g2.mat.o, spatInt.ind, forcast.ind,
                                    samples.store, N.MCMC, burn_in1, burn_in2, adapt_seq,
                                    thin, adapt, tun_r, tun_kappa, tun_lambda, print.result,
                                    traceplot, true.values, simulation, init.seed)
}
