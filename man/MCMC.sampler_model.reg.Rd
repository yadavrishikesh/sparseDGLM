% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler_model-bayes_reg.R
\name{MCMC.sampler_model.reg}
\alias{MCMC.sampler_model.reg}
\title{MCMC Sampler for Bayesian Regression Model With Only Fixed Effects}
\usage{
MCMC.sampler_model.reg(
  model,
  data_lik,
  nt,
  ns,
  p,
  q,
  Y.o,
  data.log.mean,
  data.mean,
  Y.intpl,
  Y.frcast,
  Y.st,
  ind_NA_Y,
  X.o,
  quad.X.o,
  X.intpl,
  X.frcast,
  X.st,
  X.p,
  spatInt.ind,
  forcast.ind,
  samples.store,
  N.MCMC,
  burn_in1,
  burn_in2,
  adapt_seq,
  thin,
  adapt,
  tun_r,
  tun_lambda,
  print.result,
  traceplot,
  true.values,
  simulation,
  init.seed
)
}
\arguments{
\item{data_lik}{Character, specifying the data likelihood, e.g., `"Poisson"`, `"NegB"`, etc.}

\item{nt}{Integer, the number of time points in the dataset.}

\item{ns}{Integer, the number of spatial locations.}

\item{p}{Integer, the number of dynamic temporal covariates.}

\item{q}{Integer, the number of fixed covariates.}

\item{Y.o}{Matrix of observed data (excluding spatial interpolation indices).}

\item{data.log.mean}{Numeric, the mean of the log-transformed observed data.}

\item{data.mean}{Numeric, the mean of the observed data.}

\item{Y.intpl}{Matrix of data for spatial interpolation.}

\item{Y.frcast}{Matrix of forecasted data for future time points.}

\item{Y.st}{Matrix of spatio-temporal data.}

\item{ind_NA_Y}{Logical matrix indicating missing values in `Y.o`.}

\item{X.o}{Matrix of fixed covariates for observed data.}

\item{quad.X.o}{Quadratic form of the design matrix `X.o`.}

\item{X.intpl}{Matrix of fixed covariates for spatial interpolation.}

\item{X.frcast}{Matrix of fixed covariates for forecasting.}

\item{X.st}{Matrix of fixed covariates for spatio-temporal data.}

\item{X.p}{Matrix of fixed covariates for prediction.}

\item{spatInt.ind}{Vector of spatial interpolation indices.}

\item{forcast.ind}{Vector of forecast indices.}

\item{samples.store}{Integer, the number of MCMC samples to store.}

\item{N.MCMC}{Integer, the total number of MCMC iterations.}

\item{burn_in1}{Integer, the number of iterations for the first burn-in period.}

\item{burn_in2}{Integer, the number of iterations for the second burn-in period.}

\item{adapt_seq}{Vector, indicating the sequence of iterations for adaptation.}

\item{thin}{Integer, the thinning interval for MCMC samples.}

\item{adapt}{Integer, the adaptation interval.}

\item{tun_r}{Numeric, tuning parameter for `r` in the negative binomial likelihood.}

\item{tun_lambda}{Numeric, tuning parameter for `lambda`.}

\item{print.result}{Logical, if `TRUE`, prints the MCMC results.}

\item{traceplot}{Logical, if `TRUE`, generates trace plots of MCMC samples.}

\item{true.values}{List of true parameter values (optional).}

\item{simulation}{Logical, if `TRUE`, the function runs in simulation mode.}

\item{init.seed}{Integer, seed for random number generation to ensure reproducibility.}
}
\value{
A list containing MCMC samples, trace plots, and convergence diagnostics.
}
\description{
This function performs MCMC sampling for a Bayesian regression model with dynamic temporal covariates. The sampler supports various likelihood functions and handles missing data, spatial interpolation, and forecasting.
}
\examples{
data_lik <- "Poisson"
nt <- 10
ns <- 5
p <- 3
q <- 2
Y.o <- matrix(rpois(50, lambda = 3), nrow = 10)
data.log.mean <- log(mean(Y.o))
data.mean <- mean(Y.o)
Y.intpl <- matrix(rpois(20, lambda = 3), nrow = 4)
Y.frcast <- matrix(rpois(10, lambda = 3), nrow = 2)
Y.st <- matrix(rpois(20, lambda = 3), nrow = 4)
X.o <- matrix(rnorm(100), nrow = 10)
quad.X.o <- t(X.o) \%*\% X.o
X.intpl <- matrix(rnorm(40), nrow = 4)
X.frcast <- matrix(rnorm(20), nrow = 2)
X.st <- matrix(rnorm(40), nrow = 4)
spatInt.ind <- 1:2
forcast.ind <- 1:2
samples.store <- 100
N.MCMC <- 1000
burn_in1 <- 200
burn_in2 <- 500
adapt_seq <- seq(100, 1000, by = 100)
thin <- 10
adapt <- 100
tun_r <- 0.1
tun_lambda <- 0.1
print.result <- TRUE
traceplot <- TRUE
true.values <- NULL
simulation <- FALSE
init.seed <- 123
result <- MCMC.sampler_model.reg(data_lik, nt, ns, p, q, Y.o, data.log.mean, data.mean,
                                 Y.intpl, Y.frcast, Y.st, NULL, X.o, quad.X.o, X.intpl,
                                 X.frcast, X.st, X.o, spatInt.ind, forcast.ind, samples.store,
                                 N.MCMC, burn_in1, burn_in2, adapt_seq, thin, adapt, tun_r,
                                 tun_lambda, print.result, traceplot, true.values, simulation, init.seed)
}
