% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler_model-dense.R
\name{MCMC.sampler_model.dense}
\alias{MCMC.sampler_model.dense}
\title{MCMC Sampler for Dense Spatio-Temporal Dynamic Generalized Linear Model}
\usage{
MCMC.sampler_model.dense(
  data_lik,
  nt,
  ns,
  p,
  q,
  Y.o,
  data.log.mean,
  data.mean,
  Y.intpl,
  Y.frcast,
  Y.st,
  ind_NA_Y,
  X.o,
  quad.X.o,
  X.intpl,
  X.frcast,
  X.st,
  X.p,
  Ft.o,
  F.mat.o,
  Ft.frcast,
  m0.mu,
  C0.mu,
  m0.theta,
  C0.theta,
  G,
  dist.mat.all,
  dist.mat.o,
  delta,
  spatInt.ind,
  forcast.ind,
  cor.type,
  samples.store,
  N.MCMC,
  burn_in1,
  burn_in2,
  adapt_seq,
  thin,
  adapt,
  tun_r,
  tun_kappa,
  tun_lambda,
  print.result,
  traceplot,
  true.values,
  simulation,
  init.seed,
  ...
)
}
\arguments{
\item{data_lik}{Character, specifying the data likelihood (e.g., `"Poisson"`, `"NegB"`, `"lNormal"`, etc.).}

\item{nt}{Integer, the number of time points in the dataset.}

\item{ns}{Integer, the number of spatial locations.}

\item{p}{Integer, the number of dynamic temporal covariates.}

\item{q}{Integer, the number of fixed covariates.}

\item{Y.o}{Matrix of observed data (excluding spatial interpolation indices).}

\item{data.log.mean}{Numeric, the mean of the log-transformed observed data.}

\item{data.mean}{Numeric, the mean of the observed data.}

\item{Y.intpl}{Matrix of data for spatial interpolation.}

\item{Y.frcast}{Matrix of forecasted data for future time points.}

\item{Y.st}{Matrix of spatio-temporal data.}

\item{ind_NA_Y}{Logical matrix indicating missing values in `Y.o`.}

\item{X.o}{Matrix of fixed covariates for observed data.}

\item{quad.X.o}{Quadratic form of the design matrix `X.o`.}

\item{X.intpl}{Matrix of fixed covariates for spatial interpolation.}

\item{X.frcast}{Matrix of fixed covariates for forecasting.}

\item{X.st}{Matrix of fixed covariates for spatio-temporal data.}

\item{X.p}{Matrix of fixed covariates for prediction.}

\item{Ft.o}{Matrix of dynamic temporal covariates for observed data.}

\item{F.mat.o}{3D array of dynamic temporal covariates for observed data.}

\item{Ft.frcast}{Matrix of dynamic temporal covariates for forecasting.}

\item{m0.mu}{Numeric, initial value for the space-time varying intercept.}

\item{C0.mu}{Numeric, prior variance for the space-time varying intercept.}

\item{m0.theta}{Vector, initial value for dynamic temporal covariates.}

\item{C0.theta}{Matrix, prior covariance matrix for dynamic temporal covariates.}

\item{G}{Transition matrix for the state-space model.}

\item{dist.mat.all}{Distance matrix for all locations.}

\item{dist.mat.o}{Distance matrix for observed locations.}

\item{delta}{Numeric, the maximum distance between the observed locations.}

\item{spatInt.ind}{Vector of spatial interpolation indices.}

\item{forcast.ind}{Vector of forecast indices.}

\item{cor.type}{Character, specifying the type of spatial correlation (e.g., `"Matern0.5"`, `"Matern1"`, etc.).}

\item{samples.store}{Integer, the number of MCMC samples to store.}

\item{N.MCMC}{Integer, the total number of MCMC iterations.}

\item{burn_in1}{Integer, the number of iterations for the first burn-in period.}

\item{burn_in2}{Integer, the number of iterations for the second burn-in period.}

\item{adapt_seq}{Vector, indicating the sequence of iterations for adaptation.}

\item{thin}{Integer, the thinning interval for MCMC samples.}

\item{adapt}{Integer, the adaptation interval.}

\item{tun_r}{Numeric, tuning parameter for `r` in the negative binomial likelihood.}

\item{tun_kappa}{Numeric, tuning parameter for `kappa` (spatial range parameter).}

\item{tun_lambda}{Numeric, tuning parameter for `lambda`.}

\item{print.result}{Logical, if `TRUE`, prints the MCMC results.}

\item{traceplot}{Logical, if `TRUE`, generates trace plots of MCMC samples.}

\item{true.values}{List of true parameter values (optional).}

\item{simulation}{Logical, if `TRUE`, the function runs in simulation mode.}

\item{init.seed}{Integer, seed for random number generation to ensure reproducibility.}

\item{...}{Additional arguments passed to other methods.}
}
\value{
A list containing MCMC samples, trace plots, and convergence diagnostics.
}
\description{
This function performs MCMC sampling for a dense spatio-temporal dynamic generalized linear model (DGLM). The sampler accommodates various likelihood functions and accounts for missing data, spatial interpolation, and forecasting.
}
\examples{
data_lik <- "Poisson"
nt <- 10
ns <- 5
p <- 3
q <- 2
Y.o <- matrix(rpois(50, lambda = 3), nrow = 10)
data.log.mean <- log(mean(Y.o))
data.mean <- mean(Y.o)
Y.intpl <- matrix(rpois(20, lambda = 3), nrow = 4)
Y.frcast <- matrix(rpois(10, lambda = 3), nrow = 2)
Y.st <- matrix(rpois(20, lambda = 3), nrow = 4)
X.o <- matrix(rnorm(100), nrow = 10)
quad.X.o <- t(X.o) \%*\% X.o
X.intpl <- matrix(rnorm(40), nrow = 4)
X.frcast <- matrix(rnorm(20), nrow = 2)
X.st <- matrix(rnorm(40), nrow = 4)
Ft.o <- matrix(rnorm(30), nrow = 10)
F.mat.o <- array(rnorm(150), dim = c(10, 5, 3))
Ft.frcast <- matrix(rnorm(6), nrow = 2)
m0.mu <- 0
C0.mu <- 1
m0.theta <- rep(0, 3)
C0.theta <- diag(5, 3)
G <- diag(1, 3)
dist.mat.all <- matrix(runif(25), nrow = 5)
dist.mat.o <- matrix(runif(9), nrow = 3)
delta <- 0.1
spatInt.ind <- 1:2
forcast.ind <- 1:2
samples.store <- 100
N.MCMC <- 1000
burn_in1 <- 200
burn_in2 <- 500
adapt_seq <- seq(100, 1000, by = 100)
thin <- 10
adapt <- 100
tun_r <- 0.1
tun_kappa <- 0.1
tun_lambda <- 0.1
print.result <- TRUE
traceplot <- TRUE
true.values <- NULL
simulation <- FALSE
init.seed <- 123
result <- MCMC.sampler_model.dense(data_lik, nt, ns, p, q, Y.o, data.log.mean, data.mean,
                                   Y.intpl, Y.frcast, Y.st, NULL, X.o, quad.X.o, X.intpl,
                                   X.frcast, X.st, X.o, Ft.o, F.mat.o, Ft.frcast, m0.mu,
                                   C0.mu, m0.theta, C0.theta, G, dist.mat.all, dist.mat.o,
                                   delta, spatInt.ind, forcast.ind, cor.type, samples.store,
                                   N.MCMC, burn_in1, burn_in2, adapt_seq, thin, adapt,
                                   tun_r, tun_kappa, tun_lambda, print.result, traceplot,
                                   true.values, simulation, init.seed)
}
