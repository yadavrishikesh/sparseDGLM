---
title: "Vignette-sparseDGLM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette-sparseDGLM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette demonstrates the use of the `sparseDGLM` package for spatiotemporal dynamic generalized linear models (DGLMs) for bike count data. The package supports Gaussian processes with both dense covariance and sparse precision matrices and offers MCMC-based inference and perform prediction, including, spatial interpolation, future forecasting and spatiotemporal predictions. 

Load the necessary libraries:

```{r load-libraries, warning=FALSE, message=FALSE}
library(Matrix) 
library(ggplot2)
library(gridExtra)
library(spam)
library(dplyr)
library(INLA)
library(mvtnorm)
library(sparseDGLM) 
setwd(this.path::here())
```

# Simulating Data

### Step 1: Generate Spatial Locations
Simulate 100 spatial locations uniformly in $[0,1]^2$. These locations will be further used in our analysis at the spatial sites at which we will generate the data. 

```{r simulate-locations, fig.width=6, fig.height=6}
nt <- 200
ns <- 100
set.seed(1)
loc <- data.frame(Long = runif(ns), Lat = runif(ns)) 
ggplot(loc, aes(x=Long, y =Lat)) +
  geom_point() +
  ggtitle("Spatial Locations") +
  theme_minimal()
```

### Step 2: Create Fixed Effects Covariates (Simulaute Randomly)

```{r fixed-effects-covariates}
X <- array(NA, dim = c(nt, ns, 3))
set.seed(1)
X[,,1] <- matrix(rnorm(nt * ns, sd = sqrt(2)), nrow = nt, ncol = ns)
X[,,2] <- matrix(rnorm(nt * ns, sd = sqrt(1)), nrow = nt, ncol = ns)
X[,,3] <- matrix(rnorm(nt * ns, sd = sqrt(5)), nrow = nt, ncol = ns)
```

### Step 3: Generate Temporal Components

The **`generate_harmonic_matrices`** function from the **`sparseDGLM`** package generates harmonic matrices to model **seasonal temporal dynamics** in a **dynamic linear model (DLM)** framework. This function helps incorporate **cyclical patterns** into time-series models, making it useful for **forecasting and trend analysis** in structured spatiotemporal data. 

- **Inputs:**
  - `nt`: Number of time points (here set to `nt=200`)
  - `num_harmonics`: Number of harmonics 
  - `period`: Seasonal period (e.g., `7` for weekly seasonality)

- **Outputs:**
  - `Ft.all`: **Design matrix (`Ft`)** capturing seasonal variations.
  - `G.all`: **State transition matrix (`G`)** governing the temporal evolution.


```{r generate-harmonics}
seas.period <- 7
num_harmonics <- 1
details.seas <- sparseDGLM::generate_harmonic_matrices(nt = nt, num_harmonics = num_harmonics, period = seas.period)
Ft <- details.seas$Ft.all
G <- details.seas$G.all
p <- ncol(Ft)
Wt <- diag(c(0.01, 0.02))
```

### Step 4: Simulate Data

The **`sim_synthetic_data`** function from the **`sparseDGLM`** package simulates **synthetic spatiotemporal data** based on a specified **dynamic generalized linear model (DGLM)** framework. This function is useful for simulating synthetic data for **testing and validating** spatiotemporal models before applying them to real-world datasets. 

- **Inputs:**
  - `nt`: Number of time points.
  - `model`: Type of model structure (three choices; `dense`, `sparse`, and `bayes.reg`).
  - `data_lik`: Likelihood function (e.g., `"Poisson"` for count data). Other possibilities included `NegB` and `lNormal` for Negative binomial and log-normal respectively. 
  - `loc`: Spatial locations of sites. A matrix with first column passed a Latitude and second one with the Latitude
  - `hyper`: List of **model hyperparameters**, including:
    - `r, k`: Hyperparameter of data likelihood in case of `NegB` and `lNormal` is used instead of `Poisson` 
    - `kappa`: Spatial range parameter used in the specification of spatiotemporal intercepts 
    - `sigma2`: Variance of 
    - `tau2`: Variance components of independent random effects 
    - `Wt`: Process noise covariance.
  - `beta0`: Fixed Intercept term (used only when we want to simulate from )
  - `beta`: Fixed effects regression coefficients
  - `X`: Covariate data array. An array of dimension `nt x ns x q` where `q` is the number of fixed effects covarites. 
  - `Ft, G`: Harmonic matrices for temporal dynamics.
  - `cor.type`: Spatial correlation structure (`"Matern1"` used here).
  - `theta0`: Initial state vector.
  - `mu0, C0, R0`: Initial conditions for the state process. 

- **Outputs:**
  - `sim_data`: A simulated dataset containing **spatiotemporal observations** with structured dependencies.


```{r simulate-data}
hyper <- list(r = 100, k = 0.5, kappa = 0.35, sigma2 = 0.1, tau2 = 0.05, Wt = Wt) ## model hyperparameters 
beta0 <- 1
set.seed(1)
beta <- runif(dim(X)[3])
model <- "dense"
data_lik <- "Poisson"
cor.type <- "Matern1"
sim_data <- sparseDGLM::sim_synthetic_data(
  nt = nt,
  model = model,
  data_lik = data_lik,
  loc = loc,
  hyper = hyper,
  beta0 = beta0,
  beta = beta,
  Wt = Wt,
  X = X,
  Ft = Ft,
  G = G,
  cor.type = cor.type,
  theta0 = rep(0, p),
  mu0 = 6,
  C0 = diag(ns),
  R0 = 0
)
```

### Examine the simulated dataset:

```{r examine-data, fig.width=7, fig.height=7}
par(mfrow=c(2,2))
hist(log(1+sim_data$y), xlab = expression(log(1+Y)), 
     main="Histograms of log-transformed data")
plot(log(1+sim_data$y[,1]), type ="l", xlab="Time", ylab = expression(log(1+Y[t](1))),
     main="Time series of log-transformed data at sites 1")
plot(log(1+sim_data$y[,2]), type ="l", xlab="Time", ylab = expression(log(1+Y[t](1))), 
     main="Time series of log-transformed data at sites 2")
plot(log(1+sim_data$y[,3       ]), type ="l", xlab="Time", ylab = expression(log(1+Y[t](1))), 
     main="Time series of log-transformed data at sites 3")
```

# Creating Artficially Missing Values to Asses the Prediction Performances 

```{r introduce-missing-values}
## randomly select the sites where we will remove data partially  
set.seed(1)
miss.artfical.na <- sample(1:ns, size = 10, replace = TRUE) 
## randomly select the sites where we will completely remove the data sets to asses spatial interpolations  
set.seed(1)
spatInt.ind <- sample(setdiff(1:ns, miss.artfical.na), size = 10, replace = TRUE)

Y <- sim_data$y
# Function to generate consecutive missing indices
generate_consecutive_indices <- function(total_days, num_missing) {
  missing_indices <- numeric(0)
  while (length(missing_indices) < num_missing) {
    block_size <- sample(1:min(30, num_missing - length(missing_indices)), 1)
    start <- sample(setdiff(1:total_days, missing_indices), 1)
    block <- start:(start + block_size - 1)
    block <- block[block <= total_days]
    missing_indices <- unique(c(missing_indices, block))
  }
  return(sort(missing_indices[1:num_missing]))
}

missing_range <- c(50, 75) ## range of missing values in each sites 
missing_indices <- list()
set.seed(123)
for (site in seq_along(miss.artfical.na)) {
  missing_percentage <- sample(seq(missing_range[1], missing_range[2], by = 1), 1)
  num_missing <- round((missing_percentage / 100) * nt)
  missing_indices[[site]] <- generate_consecutive_indices(nt, num_missing)
  Y[missing_indices[[site]], miss.artfical.na[site]] <- NA
}
```

# MCMC Inference and Predictions

### Step 1: Define Mesh Hyperparameters

In this section we demonstrate the R code that defines **hyperparameters** for constructing a **spatial mesh** using the **Integrated Nested Laplace Approximation (INLA)** framework. This is essential in **spatial modeling**, where the mesh discretizes the study domain to enable efficient inference. The key components are explained below:

#### **1. Mesh Hyperparameter Combinations (`mesh.hyper.comb`)**
- This **list of lists** stores four different **hyperparameter combinations** used to define the spatial mesh.
- Each combination includes:
  - `max.edge`: A vector defining the **maximum edge length** for mesh triangles in the interior and exterior.
  - `cutoff`: The **minimum allowable distance** between two mesh nodes. Smaller values create a denser mesh.
  - `offset`: A vector defining the **outer extension** of the mesh domain.

##### **Example Values:**
```r
list(max.edge = c(2, 2), cutoff = 0.1, offset = c(0.05, 0.2))
```

- Here:
  - `max.edge = c(2, 2)`: The **maximum edge length** of the mesh triangles is 2.
  - `cutoff = 0.1`: Ensures nodes closer than 0.1 units are merged.
  - `offset = c(0.05, 0.2)`: The mesh extends **0.05 units** inward and **0.2 units** outward.

#### **2. Selecting a Mesh Configuration (`mesh.hyper`)**
```{r}
model_no <- 4
## hyper-parameter used for four different combinations of mesh nodes construction
mesh.hyper.comb <- list(
  list(max.edge = c(2, 2), cutoff = 0.1, offset = c(0.05, 0.2)),
  list(max.edge = c(2, 2), cutoff = 0.06, offset = c(0.05, 0.2)),
  list(max.edge = c(2, 2), cutoff = 0.04, offset = c(0.05, 0.2)),
  list(max.edge = c(2, 2), cutoff = 0.03, offset = c(0.05, 0.2))
)
mesh.hyper <- mesh.hyper.comb[[model_no]]
```
- `model_no = 4`: Selects the **fourth** hyperparameter combination from `mesh.hyper.comb`.
- `mesh.hyper`: Stores the corresponding **mesh parameter settings**.

---

#### **3. Mesh Construction (`INLA::inla.mesh.2d`)**
```{r}
INLA.mesh <- INLA::inla.mesh.2d(
  loc = as.matrix(loc),
  max.edge = mesh.hyper$max.edge,
  cutoff = mesh.hyper$cutoff,
  offset = mesh.hyper$offset
)
```
- **Purpose**: Creates a **spatial triangulation mesh** over the study region.
- **Inputs:**
  - `loc`: Matrix of **spatial locations** (site coordinates).
  - `max.edge`: Maximum triangle edge length (from `mesh.hyper`).
  - `cutoff`: Minimum node spacing (from `mesh.hyper`).
  - `offset`: Mesh extension boundary (from `mesh.hyper`).
- **Output**: `INLA.mesh`, an object containing the **triangulated mesh**.

---

#### **4. Projection Matrix (`A.proj`)**
```{r}
A.proj <- inla.spde.make.A(mesh = INLA.mesh, loc = as.matrix(loc))
```
- **Purpose**: Projects the observation locations onto the mesh for **spatial interpolation**.
- **Input**: 
  - `mesh`: The generated **INLA mesh**.
  - `loc`: The **spatial locations**.
- **Output**: `A.proj`, a matrix mapping observation locations to mesh nodes.
- **Dimension Check**:
  ```r
  dim(A.proj)[2]
  ```
  - Returns the number of **mesh nodes**.

---

#### **5. Plotting the Spatial Mesh**
```{r, fig.width=6, fig.height=6}
par(mfrow=c(1,1))
plot(INLA.mesh)
points(loc, col=2, cex=1, pch=16)
points(loc[spatInt.ind,], col=3, cex=1, pch=16)
points(loc[miss.artfical.na,], col=4, cex=1, pch=16)
```


### Step 2: Run MCMC Sampler

To run the MCMC sampler for inference teh main functions is `MCMC.sampler.st.DGLM` which takes following input to draw the posterior sampling from the model.
- **`Y`**: The `n x T` data matrix, where `n` is the number of spatial locations and `T` is the number of temporal dimensions.

- **`X`**: The design matrix of dimension `n x T x q`, where `q` represents the number of fixed effects covariates. This matrix includes the fixed effects coefficients used in the model.

- **`loc`**: A matrix of spatial coordinates with dimensions `n x 2`, where each row corresponds to a spatial location.

- **`num_harmonics`**: The number of harmonic terms used to model the seasonal components in the data.

- **`seas.period`**: The seasonal period defining the time interval for periodicity in the data.

- **`model`**: Specifies the type of model to be used. In this case, `"sparse"` indicates that a sparse model structure is being employed.

- **`data_lik`**: The likelihood function for the observed data, defining the assumed statistical distribution for the response variable.

- **`cor.type`**: The type of spatial correlation structure used in the model, such as Matérn or exponential covariance.

- **`spatInt.ind`**: An index or indicator specifying which spatial locations are included in the spatial interaction terms.

- **`forcast.ind`**: A vector specifying the indices of future time points for which predictions or forecasts will be generated. In this case, it is set to `1:7`, meaning predictions for the next 7 time steps.

- **`N.MCMC`**: The total number of MCMC iterations to be performed in the sampler.

- **`samples.store`**: The number of posterior samples to be stored for further analysis.

- **`mesh.hyper`**: A hyperparameter setting related to the spatial mesh used in the model, which is selected from a predefined combination of mesh configurations.

- **`print.result`**: A logical value (`TRUE` or `FALSE`) indicating whether to print summary results during the MCMC process.

- **`traceplot`**: A logical value (`TRUE` or `FALSE`) specifying whether to generate trace plots of the sampled posterior parameters to assess convergence.

- **`simulation`**: A logical value (`TRUE` or `FALSE`) indicating whether the function is being run on simulated data.

- **`no_parallel_chain`**: Specifies the number of parallel MCMC chains to be executed simultaneously.

```{r mcmc-sampler}
start_time <- Sys.time()
mcmc.output <- sparseDGLM::MCMC.sampler.st.DGLM(
  Y = Y,
  X = X,
  loc = loc,
  num_harmonics = num_harmonics,
  seas.period = seas.period,
  model = "sparse",
  data_lik = data_lik,
  cor.type = cor.type,
  spatInt.ind = spatInt.ind,
  forcast.ind = 1:14,
  N.MCMC = 1e4,
  samples.store = 250,
  mesh.hyper = mesh.hyper.comb[[4]],
  print.result = FALSE,
  traceplot = FALSE,
  simulation = TRUE,
  no_parallel_chain = 1
)
end_time <- Sys.time()
run_time <- end_time - start_time
run_time
```

# Step 3: Extracting the Outputs 

### Posterior Summary of Hyperparameters 
This **extracts the posterior summary of model hyperparameters** estimated from the MCMC sampling process. The summary typically includes:

- **Posterior mean** and **credible intervals** for key model parameters.
- **Variance components**, such as:
  - `sigma2`: Process variance controlling temporal dynamics.
  - `tau2`: Measurement error variance.
- **Spatial dependence parameters**, such as:
  - `kappa`: Range parameter governing spatial correlation.
  - `rho`: Temporal autocorrelation parameter.
- **Fixed effect estimates**, including:
  - `beta0`: Intercept.
  - `beta`: Regression coefficients for covariates.
- **Harmonic component parameters**, if applicable.

```{r}
mcmc.output$summery.hyper
```

### Posterior Summary of Fixed Effects Coeffiecients  
This **extracts the posterior summary of fixed effect coefficients** estimated from the MCMC sampling process. The summary includes:

- **Posterior mean** and **credible intervals** for fixed effects.
- **Regression coefficients (`β`)**, which quantify the impact of covariates on the response variable.
- **Intercept (`β₀`)**, representing the baseline level of the response variable.
- **Uncertainty estimates**, such as:
  - Posterior standard deviation.
  - 95% credible intervals (lower and upper bounds).

This output helps in assessing the **significance** of the fixed effects in the **spatiotemporal dynamic model**, providing key insights into the influence of covariates.
```{r}
mcmc.output$summary.fixed.effects.coeff
```

### Extracting Posterior Estimates of Spatiotemporal Intercepts
This section demonstrate to extracts and visualizes the **spatiotemporal intercept estimates** from the MCMC sampling process. The spatiotemporal intercept **\(\mu_t(s)\)** represents the evolving baseline trend at different spatial locations over time.

```{r}
intcp_est_dense <- mcmc.output$summary.st.intercepot$mu.st$mean
intcp_lci_dense <- mcmc.output$summary.st.intercepot$mu.st$quant2.5
intcp_uci_dense <- mcmc.output$summary.st.intercepot$mu.st$quant97.5
intcp_true <- sim_data$mu.st[1:mcmc.output$nt, -mcmc.output$spatInt.ind]
```
- `intcp_est_dense`: **Posterior mean** of spatiotemporal intercepts.
- `intcp_lci_dense`: **Lower bound (2.5% quantile)** of the credible interval.
- `intcp_uci_dense`: **Upper bound (97.5% quantile)** of the credible interval.

```{r, fig.width=6, fig.height=6}
set.seed(1)
select.ind <- sample(1:ncol(intcp_true), size = 4, replace = FALSE)
plot_list <- list()
for (i in seq_along(select.ind)) {
  idx <- select.ind[i]
  data <- data.frame(
    Time = 1:nrow(intcp_true),
    True = intcp_true[, idx],
    Dense_Est = intcp_est_dense[, idx],
    Dense_LCI = intcp_lci_dense[, idx],
    Dense_UCI = intcp_uci_dense[, idx]
  )
  # Create ggplot
  p <- ggplot(data, aes(x = Time)) +
    geom_point(aes(y = True, color = "True"), size = 1.5) + 
    geom_ribbon(aes(ymin = Dense_LCI, ymax = Dense_UCI, fill = "Dense"), alpha = 0.3) +
    geom_line(aes(y = Dense_Est, color = "Dense"), size = 1) +
    labs(
      title = paste0("Site ", idx),
      y = expression(mu[t](s)),
      x = "Time",
      color = "Est",
      fill = "CI"
    ) +
    scale_color_manual(values = c("True" = "black", "Dense" = "blue")) +
    scale_fill_manual(values = c("Dense" = "#87CEFA")) +
    theme_minimal() +
    theme(
      legend.position = ifelse(i == length(select.ind), "bottom", "none"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5), 
      axis.title = element_text(size = 16, face = "bold"),               
      axis.text = element_text(size = 14),                              
      legend.title = element_text(size = 14, face = "bold"),            
      legend.text = element_text(size = 12),                            
      plot.caption = element_text(size = 12, hjust = 0.5)              
    )

  plot_list[[i]] <- p
}
g <- grid.arrange(grobs = plot_list, ncol = 2)
g
```
- **True values (black points)**: Represent actual intercept values.
- **Estimated intercepts (blue line)**: Show posterior mean estimates.
- **Shaded region (credible interval)**: Represents model uncertainty.

```{r, fig.width=8, fig.height=8}
intcp_est_dense <- mcmc.output$summary.st.intercepot$mu.st$mean
intcp_lci_dense <- mcmc.output$summary.st.intercepot$mu.st$quant2.5
intcp_uci_dense <- mcmc.output$summary.st.intercepot$mu.st$quant97.5
intcp_true <- sim_data$mu.st[1:mcmc.output$nt, -mcmc.output$spatInt.ind]

```



### Spatial Interpolations (Krigging)


This section **evaluates the spatial interpolation (kriging) results** by comparing predicted values with true values at spatial integration sites. Kriging is a method used to estimate values at **unobserved spatial locations** based on **observed data**.

```{r}
spatintpl_est_dense <- mcmc.output$predictions$spatial$median
spatintpl_lci_dense <- mcmc.output$predictions$spatial$quant2.5
spatintpl_uci_dense <- mcmc.output$predictions$spatial$quant97.5
spatintpl_true <- sim_data$y[1:mcmc.output$nt, mcmc.output$spatInt.ind]
```
- `spatintpl_est_dense`: **Median prediction** for spatial interpolation.
- `spatintpl_lci_dense`: **Lower bound (2.5% quantile)** of the **credible interval**.
- `spatintpl_uci_dense`: **Upper bound (97.5% quantile)** of the **credible interval**.
- `spatintpl_true`: **true observed values** \(Y_t(s)\) at the given spatial sites.

```{r, fig.width=6, fig.height=6}
set.seed(2)
select.ind <- sample(1:length(mcmc.output$spatInt.ind), size = 4, replace = FALSE)
plot_list <- list()
for (i in seq_along(select.ind)) {
  idx <- select.ind[i]
  data <- data.frame(
    Time = 1:nrow(spatintpl_true),
    True = log(1 + spatintpl_true[, idx]),
    Dense_Est = log(1 + spatintpl_est_dense[, idx]),
    Dense_LCI = log(1 + spatintpl_lci_dense[, idx]),
    Dense_UCI = log(1 + spatintpl_uci_dense[, idx])
  )

  # Create ggplot for each site
  p <- ggplot(data, aes(x = Time)) +
    geom_point(aes(y = True, color = "True"), size = 1.5) +
    geom_ribbon(aes(ymin = Dense_LCI, ymax = Dense_UCI, fill = "Dense"), alpha = 0.3) +
    geom_line(aes(y = Dense_Est, color = "Dense"), size = 1) +
    labs(
      title = paste0("Site ", mcmc.output$spatInt.ind[idx]),
      y = expression(log(1+Y[t](s))),
      x = "Time",
      color = "Est.",
      fill = "CI"
    ) +
    scale_color_manual(values = c("True" = "black", "Dense" = "#0072B2")) +
    scale_fill_manual(values = c("Dense" = "#87CEFA")) +
    theme_minimal() +
    theme(
      legend.position = ifelse(i == length(select.ind), "bottom", "none"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
      axis.title = element_text(size = 16, face = "bold"),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 14, face = "bold"),
      legend.text = element_text(size = 12)
    )

  plot_list[[i]] <- p
}
g <- grid.arrange(grobs = plot_list, ncol = 1)
g
```

### Future Forecasting 

This section evaluates the **future predictions** generated by the model for **unobserved time points** beyond the training period. The **forecasting results** are compared with the true values from simulated data, focusing on uncertainty quantification using posterior distributions.

```{r}
spatintpl_est_dense <- mcmc.output$predictions$forecast$median
spatintpl_lci_dense <- mcmc.output$predictions$forecast$quant2.5
spatintpl_uci_dense <- mcmc.output$predictions$forecast$quant97.5
spatintpl_true <- sim_data$y[-(1:mcmc.output$nt), -mcmc.output$spatInt.ind]
```
- `spatintpl_est_dense`: **Median posterior prediction** for future values.
- `spatintpl_lci_dense`: **Lower bound (2.5% quantile)** of the **credible interval**.
- `spatintpl_uci_dense`: **Upper bound (97.5% quantile)** of the **credible interval**.

```{r, fig.width=6, fig.height=6}
set.seed(1)
select.ind <- sample(1:mcmc.output$ns, size = 4, replace = FALSE)
plot_list <- list()
for (i in seq_along(select.ind)) {
  idx <- select.ind[i]
  data <- data.frame(
    Time = 1:nrow(spatintpl_true),
    True = log(1 + spatintpl_true[, idx]),
    Dense_Est = log(1 + spatintpl_est_dense[, idx]),
    Dense_LCI = log(1 + spatintpl_lci_dense[, idx]),
    Dense_UCI = log(1 + spatintpl_uci_dense[, idx])
  )

  # Create ggplot for each site
  p <- ggplot(data, aes(x = Time)) +
    geom_point(aes(y = True, color = "True"), size = 1.5) +  # Slightly larger points
    geom_ribbon(aes(ymin = Dense_LCI, ymax = Dense_UCI, fill = "Dense"), alpha = 0.3) +
    geom_line(aes(y = Dense_Est, color = "Dense"), size = 1) +
    labs(
      title = paste0("Site ", idx),
      y = expression(log(1+Y[t](s))),
      x = "Time",
      color = "Est",
      fill = "CI"
    ) +
    scale_color_manual(values = c("True" = "black","Dense" = "blue")) +
    scale_fill_manual(values = c("Dense" = "#87CEFA")) +
    theme_minimal() +
    theme(
      legend.position = ifelse(i == length(select.ind), "bottom", "none"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),  # Larger title
      axis.title = element_text(size = 16, face = "bold"),               # Larger axis titles
      axis.text = element_text(size = 14),                              # Larger axis text
      legend.title = element_text(size = 14, face = "bold"),            # Larger legend title
      legend.text = element_text(size = 12),                            # Larger legend text
      plot.caption = element_text(size = 12, hjust = 0.5)               # Larger captions
    )

  plot_list[[i]] <- p
}
g <- grid.arrange(grobs = plot_list, ncol = 2)
g
```


### Spatiotemproal Prediction 

This section evaluates the **spatiotemporal predictions** by comparing the model’s posterior predictions with true values across both **space and time**. The focus is on estimating the **evolution of values at specific spatial locations over future time points**.

```{r}
spatintpl_est_dense <- mcmc.output$predictions$space.time$median
spatintpl_lci_dense <- mcmc.output$predictions$space.time$quant2.5
spatintpl_uci_dense <- mcmc.output$predictions$space.time$quant97.5
spatintpl_true <- sim_data$y[-(1:mcmc.output$nt), mcmc.output$spatInt.ind]
```
- `spatintpl_est_dense`: **Posterior median estimate** for spatiotemporal predictions.
- `spatintpl_lci_dense`: **Lower bound (2.5% quantile)** of the **credible interval**.
- `spatintpl_uci_dense`: **Upper bound (97.5% quantile)** of the **credible interval**.

```{r, fig.width=6, fig.height=6}
set.seed(12)
select.ind <- sample(1:length(mcmc.output$spatInt.ind), size = 6, replace = FALSE)
plot_list <- list()
for (i in seq_along(select.ind)) {
  idx <- select.ind[i]
  data <- data.frame(
    Time = 1:nrow(spatintpl_true),
    True = log(1 + spatintpl_true[, idx]),
    Dense_Est = log(1 + spatintpl_est_dense[, idx]),
    Dense_LCI = log(1 + spatintpl_lci_dense[, idx]),
    Dense_UCI = log(1 + spatintpl_uci_dense[, idx])
  )
  p <- ggplot(data, aes(x = Time)) +
    geom_point(aes(y = True, color = "True"), size = 1.5) + 
    geom_ribbon(aes(ymin = Dense_LCI, ymax = Dense_UCI, fill = "Dense"), alpha = 0.3) +
    geom_line(aes(y = Dense_Est, color = "Dense"), size = 1) +
    labs(
      title = paste0("Site ", idx),
      y = expression(log(1+Y[t](s))),
      x = "Time",
      color = "Est.",
      fill = "CI"
    ) +
    scale_color_manual(values = c("True" = "black", "Dense" = "#0072B2")) +
    scale_fill_manual(values = c("Dense" = "#87CEFA")) +
    theme_minimal() +
    theme(
      legend.position = ifelse(i == length(select.ind), "bottom", "none"),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),  # Larger, bold title
      axis.title = element_text(size = 16, face = "bold"),               # Larger axis titles
      axis.text = element_text(size = 14),                              # Larger axis text
      legend.title = element_text(size = 14, face = "bold"),            # Larger legend title
      legend.text = element_text(size = 12)                             # Larger legend text
    )

  plot_list[[i]] <- p
}
g <- grid.arrange(grobs = plot_list, ncol = 2)
g
```


### Coefficents of Dynamic Temproal Components

This section evaluates the **dynamic temporal coefficients** (\(\theta_t\)), comparing the model’s posterior estimates with the true underlying values. These coefficients represent **time-evolving effects** that capture temporal dependencies in the model.

```{r}
est.temp.eff <- mcmc.output$summary.dynamic.temp.coeff$mean
lci.temp.eff <- mcmc.output$summary.dynamic.temp.coeff$quant2.5
uci.temp.eff <- mcmc.output$summary.dynamic.temp.coeff$quant97.5
true.temp.eff <- sim_data$theta[1:mcmc.output$nt, ]
```
- `est.temp.eff`: **Posterior mean estimate** of the temporal coefficients.
- `lci.temp.eff`: **Lower bound (2.5% quantile)** of the **credible interval**.
- `uci.temp.eff`: **Upper bound (97.5% quantile)** of the **credible interval**.

```{r, fig.width=6, fig.height=6}
plot_list <- list()
for (i in 1:ncol(true.temp.eff)) {
  data <- data.frame(
    Time = 1:nrow(true.temp.eff),
    True = true.temp.eff[, i],
    Est = est.temp.eff[, i],
    LCI = lci.temp.eff[, i],
    UCI = uci.temp.eff[, i]
  )
  ran <- c(
    min(data$True, data$Est, data$LCI, data$UCI, na.rm = TRUE),
    max(data$True, data$Est, data$LCI, data$UCI, na.rm = TRUE)
  )
  p <- ggplot(data, aes(x = Time)) +
    geom_point(aes(y = True, color = "True"), size = 1.5) +
    geom_line(aes(y = Est, color = "Estimated"), size = 1.5) +
    geom_ribbon(aes(ymin = LCI, ymax = UCI, fill = "CI"), alpha = 0.3) +
    scale_color_manual(values = c("True" = "black", "Estimated" = "red")) +
    scale_fill_manual(values = c("CI" = "blue")) +
    labs(
      y = expression(theta[t]),
      x = "Time",
      color = "Legend",
      fill = "Legend"
    ) +
    coord_cartesian(ylim = ran) +
    theme_minimal() +
    theme(
      legend.position = ifelse(i == ncol(true.temp.eff), "bottom", "none"),  
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
      axis.title = element_text(size = 16, face = "bold"),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 14, face = "bold"),
      legend.text = element_text(size = 12)
    )

  plot_list[[i]] <- p
}
g <- grid.arrange(grobs = plot_list, ncol = 1)
g
```
